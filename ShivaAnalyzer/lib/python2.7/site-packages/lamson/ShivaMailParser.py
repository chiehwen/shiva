#!/usr/bin/env python
"""
This module accepts spam file name as parameter and returns all parsed fields as items of a dictionary
In current state, it's accepting spam file name as parameter, parsing all fields, saving in a dictionary and forwarding to another module

"""

import email.Message
import email.Parser
from email.header import decode_header
import os, sys, logging, re
import MySQLdb as mdb
import ShivaLinkParser, ShivaMailRelayer, ShivaConfig
import time, datetime
import hashlib								# Shiva - to calculate the md5 of attachment and inline files

# Global dictionary to store parsed fields of spam
mailFields = {'headers':'', 'to':'', 'from':'', 'subject':'', 'date':'', 'firstSeen':'', 'lastSeen':'', 'firstRelayed':'', 'lastRelayed':'', 'sourceIP':'', 'sensorID':'', 'text':'', 'html':'', 'inlineFileName':[], 'inlineFile':[], 'inlineFileMd5':[], 'attachmentFileName':[], 'attachmentFile':[], 'attachmentFileMd5':[], 'links':[], 'spam_id':''}
#mailFields = {'to':'', 'from':'', 'subject':'', 'date':'', 'text':'', 'html':'', 'inlineFileName':[], 'inlineFile':[], 'inlineFileMd5':[], 'attachmentFileName':[], 'attachmentFile':[], 'attachmentFileMd5':[], 'links':[]}
# Attachment file type is retrieved on fly


def md5Checksum(filepath):
  #fh = open(filepath, 'rb')
  m = hashlib.md5()
  
  #while True:
    ## Don't read the entire file at once ....
    #data = fh.read(8192)
    #if not data:
      #break
    #m.update(data)
  m.update(filepath)  
  return m.hexdigest()

## Updated on 12th Dec, 2012 - md5sum was buggy  
def writePartsRecurse(msg):  
  """
  This module recursively parses all fields of multipart spam mail
  """
  while isinstance(msg.get_payload(),email.Message.Message):
    msg=msg.get_payload()
  
  if msg.is_multipart():
    for subMsg in msg.get_payload():
      writePartsRecurse(subMsg)
  else:
    file_name=msg.get_filename()
    content=msg.get_content_type()
    logging.critical("content type::::: %s" % content)
    logging.critical("file name::::: %s" % file_name)
    if msg.get_content_type() == 'text/plain':								# value of content-dispostion is None in this case
      mailFields['text'] = msg.get_payload(decode=True)							# decode says - if in base64, decode the value	
      #mailFields['text'] = msg.get_payload()
    elif msg.get_content_type() == 'text/html':								# value of content-dispostion is None in this case					
      mailFields['html'] = msg.get_payload(decode=True)
      #mailFields['html'] = msg.get_payload()
    elif msg['Content-Disposition'] != None and msg['Content-Disposition'].find('inline;') >= 0:	# if 'inline' file found
      mailFields['inlineFile'].append(msg.get_payload())
      mailFields['inlineFileName'].append(msg.get_filename())
      mailFields['inlineFileMd5'].append(md5Checksum((msg.get_payload()).decode('base64')))			## msg.get_payload is in base64, decode it before finding md5sum
    elif msg['Content-Disposition'] != None and msg['Content-Disposition'].find('attachment;') >= 0:	# if attachment found
      mailFields['attachmentFile'].append(msg.get_payload())
      mailFields['attachmentFileName'].append(msg.get_filename())
      mailFields['attachmentFileMd5'].append(md5Checksum((msg.get_payload()).decode('base64')))
      #fd.write(i[1].decode('base64'))
    elif msg.get_filename() != None:											## Sometimes field "Content-Disposition" is missing, field "attachment" is missing but "file name" is there with binary content
      mailFields['attachmentFile'].append(msg.get_payload())
      mailFields['attachmentFileName'].append(msg.get_filename())
      #mailFields['attachmentFileMd5'].append(hashlib.md5(msg.get_payload()).hexdigest())
      mailFields['attachmentFileMd5'].append(md5Checksum((msg.get_payload()).decode('base64')))
    else:												# if nothing matched
      logging.critical("[-] --------- (Module ShivaParser.py) No match for text/html/content_type or Content-Disposition -----------------")
      #ShivaConfig.errorHandling(key, msgMailRequest)
      #return None
 
  return None  
  
'''
def writePartsRecurse(msg):  
  """
  This module recursively parses all fields of multipart spam mail
  """
  while isinstance(msg.get_payload(),email.Message.Message):
    msg=msg.get_payload()
  
  if msg.is_multipart():
    for subMsg in msg.get_payload():
      writePartsRecurse(subMsg)
  else:
    file_name=msg.get_filename()
    content=msg.get_content_type()
              
    if msg.get_content_type() == 'text/plain':								# value of content-dispostion is None in this case
      mailFields['text'] = msg.get_payload(decode=True)							# decode says - if in base64, decode the value	
      #mailFields['text'] = msg.get_payload()
    elif msg.get_content_type() == 'text/html':								# value of content-dispostion is None in this case					
      mailFields['html'] = msg.get_payload(decode=True)
      #mailFields['html'] = msg.get_payload()
    elif msg['Content-Disposition'] != None and msg['Content-Disposition'].find('inline;') >= 0:	# if 'inline' file found
      mailFields['inlineFile'].append(msg.get_payload())
      mailFields['inlineFileName'].append(msg.get_filename())
      mailFields['inlineFileMd5'].append(hashlib.md5(msg.get_payload()).hexdigest())
    elif msg['Content-Disposition'] != None and msg['Content-Disposition'].find('attachment;') >= 0:	# if attachment found
      mailFields['attachmentFile'].append(msg.get_payload())
      mailFields['attachmentFileName'].append(msg.get_filename())
      mailFields['attachmentFileMd5'].append(hashlib.md5(msg.get_payload()).hexdigest())
    else:												# if nothing matched
      logging.critical("[-] --------- (Module ShivaParser.py) No match for text/html/content_type or Content-Disposition -----------------")
 
  return None
'''

"""
Module for converting date and time given by Lamson framework to a format undertood my MySQL
Argument to be passed is to function is string of date and time given by lamson and return value is MySQL formatted string for date and time.

lamson_passed_date = "Thu, 14 Jun 2012 20:44:25 IST"
desired_date_format= "2012-06-15 18:00:10"  

Example: 

date_covert.convert_date("lamson_passed_date")


def convert_date(lamson_passed_date):
  #logging.critical("date: %s", lamson_passed_date)
  month_numbers = {'Jan': '01', 'Feb': '02', 'Mar': '03', 'Apr': '04', 'May': '05', 'Jun': '06', 'Jul': '07', 'Aug': '08', 'Sep': '09', 'Oct': '10', 'Nov': '11', 'Dec': '12'}
  date_number = lamson_passed_date.split()[1]
  date_year = lamson_passed_date.split()[3]
  date_time = lamson_passed_date.split()[4]
  date_month = month_numbers[lamson_passed_date.split()[2]]
  MySQL_reformed_date = date_year + "-" + date_month + "-" + date_number + " " + date_time
  return MySQL_reformed_date
"""

def main(key, msgMailRequest, exeSql):
  """
  This function gets called from queueFilter.filter()
  """
  global mailFields
  #mailFields = {'to':'', 'from':'', 'subject':'', 'date':'', 'text':'', 'html':'', 'inlineFileName':[], 'inlineFile':[], 'inlineFileMd5':[], 'attachmentFileName':[], 'attachmentFile':[], 'attachmentFileMd5':[], 'links':[]}
  mailFields = {'headers':'', 'to':'', 'from':'', 'subject':'', 'date':'', 'firstSeen':'', 'lastSeen':'', 'firstRelayed':'', 'lastRelayed':'', 'sourceIP':'', 'sensorID':'', 'text':'', 'html':'', 'inlineFileName':[], 'inlineFile':[], 'inlineFileMd5':[], 'attachmentFileName':[], 'attachmentFile':[], 'attachmentFileMd5':[], 'links':[], 'spam_id':''}
  #logging.critical("[!] --------- Inside spamParse module -----------------")
  
  # 'key' contains the name of spam file retrieved from queue
  try:
    mailFile=open(ShivaConfig.queuePath + key,"rb")
    p=email.Parser.Parser()
    msg=p.parse(mailFile)
    mailFile.close()
    
     ## Extracting whole header - not individual fields - Nov, 2012
    f = open(ShivaConfig.queuePath + key)
    msgmsg = email.message_from_file(f)
    pp = email.parser.HeaderParser()
    hh = pp.parsestr(msgmsg.as_string())
    
    headerString = ''
    for h in hh.items():
      headerString += str(h) + '\n'						# h is a tuple value. Converting to string to add a string to it
      #headerString = headerString + '\n'
    #mailFields['headers'] = hh.items()
    mailFields['headers'] = headerString
    #print "typeof header: ", type(mailFields['headers'])
    mailFields['headers'] = str(mailFields['headers']).replace("'", "")
    
  except IOError:
    logging.critical("[-] Error (Module ShivaMailParser.py) - could not open|write file %s \n" % key)
    ShivaConfig.errorHandling(key, msgMailRequest)
    return None

  try:
    # filling up basic fields of dictionary, rest get their values only after reverse parsing of multipart spam mail
    try:	
      # "to" field - considered it won't be in unicode, else write code to handle it
      mailFields['to'] = msg['to'].replace("'", "")
    except:
      logging.critical("[-] Error (Module ShivaMailParser.py) - some issue in parsing 'to' field %s" % key)
      logging.critical("to: %s", mailFields['to'])
      ShivaConfig.errorHandling(key, msgMailRequest)
      return None
    
    try:
      # "from" field - could be normal or unicode, but we are stipping of everything but just the mail id
      # from_field, encoding = decode_header(msg.get('from'))[0]								# It failed for a case and output was just a double quote
      # logging.critical("from: %s encoding: %s" % (from_field, encoding))
      from_field = msg['from']
      
      if from_field != None:													# Seen cases where "from" field had value "none"
	#mailFields['from'] = from_field.split(" ")[-1].replace("<","").replace(">","")
	#mailFields['from'] = from_field.split(" ")[-1]
	#logging.critical("from: %s", from_field)
	#mailFields['from'] = mailFields['from'].encode('unicode_escape')
	regex_from = r'''([\w\-\.+]+@\w[\w\-]+\.+[\w\-]+)'''									# Just looking for mail id
	mailFields['from'] = re.findall (re.compile(regex_from), from_field)[0]
	#logging.critical("from after regex: %s", mailFields['from'])
	mailFields['from'] = mailFields['from'].replace("'", "")
	mailFields['from'] = mailFields['from'].replace('"', '')
      else:
	logging.critical("[-] Info ShivaMailParser.py - From field has value None")
	pass
      
    except:
      logging.critical("[-] Error (Module ShivaMailParser.py) - some issue in parsing 'from' field %s" % key)
      logging.critical("from: %s", mailFields['from'])
      ShivaConfig.errorHandling(key, msgMailRequest)
      return None 
    #mailFields['from'] = mailFields['from'].replace('\n', '<br/>')
    #mailFields['from'] = mailFields['from'].encode('unicode_escape')
    
    try:
      # "subject" field - could be normal or unicode
      #logging.critical("fucking mail subject: %s", msg.get('subject'))
      subject, encoding = decode_header(msg.get('subject'))[0]									# Seen cases of unicode. Function returns the encoding type if any
  
      if encoding == None:
	#logging.critical("subject0: %s encoding0: %s" % (subject, encoding))
	mailFields['subject'] = subject
	pass
      else:
	#logging.critical("subject1: %s encoding1: %s" % (subject.decode(encoding), encoding))
	mailFields['subject'] = subject.decode(encoding)
	#logging.critical("mailFields['subject b0nd']: %s", mailFields['subject'])
	mailFields['subject'] = mailFields['subject'].encode('utf-8')								# Need to encode('utf-8') else won't be able to push into DB
  
      if msgMailRequest['subject'] != None:
	#logging.critical("len of sub: %s", len(msgMailRequest['subject']))
	#logging.critical("msgMailRequest['subject']: %s", msgMailRequest['subject'])
	#logging.critical("msg['subject']: %s", msg['subject'])
	#mailFields['subject'] = msgMailRequest['subject']
	#mailFields['subject'] = mailFields['subject'].encode('unicode_escape')
	mailFields['subject'] = mailFields['subject'].replace("'", "")
	mailFields['subject'] = mailFields['subject'].replace('"', '')
	#logging.critical("mailFields['subject']-after replacing quotes: %s", mailFields['subject'])
      else:
	logging.critical("[-] Info ShivaMailParser.py - Subject field has value None")
	pass
    except:
      logging.critical("[-] Error (Module ShivaMailParser.py) - some issue in parsing 'subject' field %s" % key)
      logging.critical("subject: %s", mailFields['subject'])
      ShivaConfig.errorHandling(key, msgMailRequest)
      return None
    
    try:
      #pass
      # The files names are generated in a way that last two fields of file name indicates sourceIP and sensorID
      mailFields['sourceIP'] = key.split("-")[-2]
      mailFields['sensorID'] = key.split("-")[-1]    
    except:
      logging.critical("[-] Error (Module ShivaMailParser.py) - some issue in parsing 'sourceIP and sensorID' field %s" % key)
      ShivaConfig.errorHandling(key, msgMailRequest)
      return None
      #pass
      
    try:
      # call function to obtain rest of the fields - it handles multipart mails as well
      writePartsRecurse(msg)
    except:
      logging.critical("[-] Error (Module ShivaMailParser.py) - some issue in writePartsRecurse function %s" % key)
      ShivaConfig.errorHandling(key, msgMailRequest)
      return None
    
    # remove single and double quotes from various fields, they break lamson server, this could be done in writePartsRecurse function itself
    try:
      #if msgMailRequest['text'] != None:
      if mailFields['text'] != None:
	mailFields['text'] = mailFields['text'].replace("'", "")
      #if msgMailRequest['html'] != None:
      if mailFields['html'] != None:
	#logging.critical("replacing single quotes in HTML")
	mailFields['html'] = mailFields['html'].replace("'", "")
    except:
      logging.critical("[-] Error (Module ShivaMailParser.py) - some issue in 'text' and 'html' field %s" % key)
      logging.critical("text: %s", mailFields['text'])
      logging.critical("html: %s", mailFields['html'])
      ShivaConfig.errorHandling(key, msgMailRequest)
      return None
    
    # parse different parts of spam (text, html, inline) and hunt for URLs
    try:
      mailFields['links'] = ShivaLinkParser.parser(mailFields['html'])
      mailFields['links'].extend(ShivaLinkParser.parser(mailFields['text']))
    except:
      logging.critical("[-] Error (Module ShivaMailParser.py) - some issue in parsing 'links' field %s" % key)
      logging.critical("links: %s", mailFields['links'])
      ShivaConfig.errorHandling(key, msgMailRequest)
      return None
    
    # Timestamping when spam is parsed by our code; not the original time stamping
    mailFields['date'] =  datetime.date.today()
    mailFields['firstSeen'] =  datetime.datetime.now()
    mailFields['lastSeen'] =  datetime.datetime.now()
    mailFields['firstRelayed'] =  datetime.datetime.now()
    mailFields['lastRelayed'] =  datetime.datetime.now()
    
    # Md5 of combination of "from", "subject" and "date" to differentiate amongs spams. This key is indexed in DB for fast searching for decision making
    #comboMD5 = str(mailFields['from']) + str(mailFields['subject']) + str(mailFields['date'])
    spam_id = str(mailFields['from']) + str(mailFields['subject'])
    mailFields['spam_id'] = hashlib.md5(spam_id).hexdigest()
    #logging.critical("comboMD5: %s", mailFields['comboMD5'])
  
  except:
    logging.critical("[-] Error (Module ShivaMailParser.py) - some issue in parsing file %s" % key)
    ShivaConfig.errorHandling(key, msgMailRequest)
    return None
     
  # Call to ShivaMailRelayer.relay function which determines whether spam is new or old
  ShivaMailRelayer.relay(mailFields, key, msgMailRequest, exeSql)
  return None